
<!DOCTYPE html>
<html>
<head>
    <title>隨機地城</title>
    <style>
        table {
            border-collapse: collapse;
        }
        td {
            width: 20px;
            height: 20px;
            text-align: center;
        }
        .wall {
			background-image: url("https://drive.google.com/uc?export=view&id=1YD9CHj8zRs-x-Sw00Fh_nmTFI9CyvqO_");
        }
        .monster {
			background-image: url("https://drive.google.com/uc?export=view&id=1QctgmYWrojpsFWmUIsfVU8mP6r-8hL3z");
        }
        .treasure {
			background-image: url("https://drive.google.com/uc?export=view&id=1vUXivbstGGf8-MVaTo_hdK07IreEpjWQ");
        }
        .player {
			background-image: url("https://drive.google.com/uc?export=view&id=1-6HhmroiJrkPUw2LhiDY-nb46K-kUYSA");
			animation:blink 1.9s infinite
        }
		.baseGround {
			background-color:rgb(0,139,139);
		}
        .mist {
            background-color: black;
		    opacity: 0.5;
        }
		@keyframes blink {
		 0% {
		  opacity: 0;
		 }
		 50% {
		  opacity: 1;
		 }
		 100% {
		  opacity: 0;
		 }
    </style> 
</head>
<body>
    <div id="status"></div> 
	<textarea id="log" style="width: 469px; height: 67px;"></textarea>
    <table id="map" class ="baseGround"></table>
    <script>
        const status = document.querySelector('#status');
        const log = document.querySelector('#log');
        const map = document.querySelector('#map');
        const width = 20;
        const height = 20;
        const mapData = [];
        const monsters = [];
        const treasures = [];
        const touchSlideDistance = 100;

        for (let y = 0; y < height; y++) {
            mapData.push([]);
            const row = document.createElement('tr');
            for (let x = 0; x < width; x++) {
                const cell = document.createElement('td');
                cell.classList.add('mist');
                if (Math.random() < 0.2) {
                    mapData[y].push('#');  
                } else if (Math.random() < 0.1) {
					mapData[y].push('M'); 
                    monsters.push({
                        x,
                        y,
                        hp: Math.floor(Math.random() * 20) + 10,
                        atk: Math.floor(Math.random() * 5) + 1,
                        def: Math.floor(Math.random() * 3)
                    });
                } else if (Math.random() < 0.05) {
                    mapData[y].push('T'); 
					var treasureType = Math.random();   
					treasures.push({
                        x,
                        y,
                        hp: treasureType >= 0.7 ?  Math.floor(Math.random() * 10) : 0 ,
                        atk: (0.3 < treasureType && treasureType < 0.7) ? Math.floor(Math.random() * 3) : 0,
                        def: treasureType <= 0.3 ? Math.floor(Math.random() * 3) : 0
                    });
                } else {
                    mapData[y].push('.'); 
                }
                row.appendChild(cell);
            }
            map.appendChild(row);
        }

        const player = {
            x: Math.floor(width / 2),
            y: Math.floor(height / 2),
            hp: 100,
            atk: 10,
            def: 0
        };
        updateStatus();
        mapData[player.y][player.x] = 'P';  
        map.children[player.y].children[player.x].classList.add('player');

        function updateStatus() {
            status.textContent = `HP: ${player.hp} ATK: ${player.atk} DEF: ${player.def}`;
        }

        function attack(attacker, defender) { 
			const damage = Math.max(0, attacker.atk - defender.def);
            defender.hp -= damage;
            log.value += `${attacker === player ? 'Player' : 'Monster'} Attck!Dealing ${damage} damage to ${defender === player ? 'Player' : 'Monster'}\n`;
            if (defender.hp <= 0) {
                if (defender === player) {
                    alert('Game Over!');
                }else {
                    log.value += 'Monster is defeated!\n';
                    const index = monsters.findIndex(monster => monster === defender);
                    if (index !== -1) {
                        monsters.splice(index, 1);
                        mapData[defender.y][defender.x] = '.';
                        map.children[defender.y].children[defender.x].classList.remove('monster');
						
						if(monsters.length == 0){
							setTimeout(
								function(){
									alert('Dungeon Clear!');
								}
							,1000);
						}
                    }
                }
				
            }
			log.scrollTop = log.scrollHeight;
        }

        document.addEventListener('keydown', ControlEvent,false);
        document.addEventListener('touchstart', handleTouchStart,false); 
        document.addEventListener('touchmove', ControlEvent,false);

		var xDown = null;                                                        
		var yDown = null;

		function getTouches(evt) { 
		  return evt.touches ||             // browser API
				 evt.originalEvent.touches; // jQuery
		}                                                     
																				 
		function handleTouchStart(evt) {  
			const firstTouch = getTouches(evt)[0];                                      
			xDown = firstTouch.clientX;                                      
			yDown = firstTouch.clientY;                                      
		};               
		
		function ControlEvent(event){
		
            let newX = player.x;
            let newY = player.y;
			let xWay = 0;
			let yWay = 0;
			
            if (event.key === 'ArrowUp') {
                newY--;
				yWay--;
            } else if (event.key === 'ArrowDown') {
                newY++;
				yWay++;
            } else if (event.key === 'ArrowLeft') {
                newX--;
				xWay--;
            } else if (event.key === 'ArrowRight') {
                newX++;
				xWay++;
            } else if (event.key === 'Space') {
            }
			
			if (event.key === '2') {
                newY++;
				yWay++;
            } else if (event.key === '8') {
                newY--;
				yWay--;
            } else if (event.key === '4') {
                newX--;
				xWay--;
            } else if (event.key === '6') {
                newX++;
				xWay++;
            } else if (event.key === '9') {
				newY--;
                newX++;
				yWay--;
				xWay++;
            } else if (event.key === '7') {
				newY--;
                newX--;
				yWay--;
				xWay--;
            } else if (event.key === '3') {
				newY++;
                newX++;
				yWay++;
				xWay++;
            } else if (event.key === '1') {
				newY++;
                newX--;
				yWay++;
				xWay--;
            }  

            // 處理觸控螢幕
            if(event.touches)
            { 
                if ( ! xDown || ! yDown ) {
                    return;
                }

                var xUp = event.touches[0].clientX;                                    
                var yUp = event.touches[0].clientY;

                var xDiff = xDown - xUp;
                var yDiff = yDown - yUp;

                if ( Math.abs( xDiff ) > Math.abs( yDiff ) ) { 
                    if ( xDiff > touchSlideDistance ) {
                        newX--; 
						xWay--;
                    } else if( xDiff < -touchSlideDistance ){
                        newX++; 
						xWay++;
                    } else　{
                        return;
                    }                       
                    
                } 
                else {
                    
                    if ( yDiff > touchSlideDistance ) {
                        newY--; 
						yWay--;
                    } else if( yDiff < -touchSlideDistance ){ 
                        newY++;
						yWay++;
                    } else　{
                        return;
                    }                                                                   
                } 
            
                xDown = null;										
                yDown = null;
            }
			PlayerMove(newX,newY,xWay,yWay);
        } 
		
		function PlayerMove(newX,newY,xWay,yWay)
		{ 
			// 清除迷霧
			ClearMist(newX,newY,xWay,yWay);
            
			if (newX >= 0 && newX < width &&
                newY >= 0 && newY < height && 
                mapData[newY][newX] !== '#' && 
                !map.children[newY].children[newX].classList.contains('mist') ) {
                if (mapData[newY][newX] === 'M') {
                    const monster = monsters.find(monster => monster.x === newX && monster.y === newY);
                    if (monster) {
                        attack(player, monster);
                        attack(monster, player);
                        updateStatus();
                    }
                } else if (mapData[newY][newX] === 'T') {
					
					const treasure = treasures.find(treasure => treasure.x === newX && treasure.y === newY);
                    player.hp+=treasure.hp;
                    player.atk+=treasure.atk;
                    player.def+=treasure.def; 
					log.value += `Got Treasure!hp+${treasure.hp} atk+${treasure.atk} def+${treasure.def}!\n`;
                    updateStatus();
                    mapData[newY][newX] = '.';
                    map.children[newY].children[newX].classList.remove('treasure');
                } else { 
					mapData[player.y][player.x] = '.';
                    map.children[player.y].children[player.x].classList.remove('player');
                    player.x = newX;
                    player.y = newY;
                    map.children[player.y].children[player.x].classList.add('player');  
					mapData[player.y][player.x] = 'P';
				}
            }  
			
			monsters.forEach(element => {     
						var xMove = Math.round(Math.random());
						var yMove = Math.round(Math.random()); 
						var newMx = Math.random() > 0.5 ? element.x + xMove : element.x - xMove;
						var newMy = 0;
						// x沒有動再動y，總之避免怪物斜走
						if(xMove === 0)
							newMy = Math.random() > 0.5 ? element.y + yMove : element.y - yMove;
		
						if(newMy === player.y && newMx === player.x)
						{
							attack(player, element);
							attack(element, player);
							updateStatus();
						}
						else if(newMx >= 0 && newMx < width && newMy >= 0 && newMy < height &&
						   mapData[newMy][newMx] !== '#' &&
						   mapData[newMy][newMx] !== 'T' &&
						   mapData[newMy][newMx] !== 'M' 
						   )
						{
							mapData[element.y][element.x] = '.';
							map.children[element.y].children[element.x].classList.remove('monster'); 
							element.x = newMx;
							element.y = newMy;
                            if(!map.children[element.y].children[element.x].classList.contains('mist'))
                            {
                                map.children[element.y].children[element.x].classList.add('monster');  
							}
							mapData[element.y][element.x] = 'M';
						}
						
					}); 
		}
		
		function GetRound(targetX,targety)
		{
			var roundArr = [
				{x : targetX+1,y : targety}, 
				{x : targetX+1,y : targety+1},
				{x : targetX+1,y : targety-1},
				{x : targetX,  y : targety+1},
				{x : targetX,  y : targety+-1},
				{x : targetX-1,y : targety}, 
				{x : targetX-1,y : targety+1},
				{x : targetX-1,y : targety-1} 
			];
			
			return roundArr;
		}
		
		function GetView(targetX,targety,xWay,yWay)
		{
			if(yWay === 0)
			{
				return [ 
					{x : targetX+xWay, y : targety+1},
					{x : targetX+xWay, y : targety},
					{x : targetX+xWay, y : targety-1}, 
					{x : targetX, y : targety},
				];
			}
			else if(xWay === 0)
			{
				return [
					{x : targetX+1, y : targety+yWay},
					{x : targetX  , y : targety+yWay},
					{x : targetX-1, y : targety+yWay}, 
					{x : targetX  , y : targety},
				];
			} 
		}
		
		function ClearMist(x,y,xWay,yWay)
		{ 
			var roundArr = GetView(x,y,xWay,yWay);
			
			roundArr.forEach(e => {
				if(map.children[e.y].children[e.x].classList.contains('mist'))
				{
					map.children[e.y].children[e.x].classList.remove('mist'); 
					switch (mapData[e.y][e.x])
					{
						case '#':{
							map.children[e.y].children[e.x].classList.add('wall');
							break;
						}
						case 'T':{
							map.children[e.y].children[e.x].classList.add('treasure');
							return;
							break;
						}
						case 'M':{
							map.children[e.y].children[e.x].classList.add('monster');
							break;
						}
						case '.':{ 
							break;
						}
					} 
				}
			}); 
		}
    </script>
</body>
</html>