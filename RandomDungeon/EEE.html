
<!DOCTYPE html>
<html>
<head>
    <title>隨機地城</title>
    <style>
        table {
            border-collapse: collapse;
        }
        td {
            width: 20px;
            height: 20px;
            text-align: center;
        }
        .wall {
			background-image: url("https://drive.google.com/file/d/1YD9CHj8zRs-x-Sw00Fh_nmTFI9CyvqO_/preview");
        }
        .monster {
			background-image: url("https://drive.google.com/uc?export=view&id=1QctgmYWrojpsFWmUIsfVU8mP6r-8hL3z");
        }
        .treasure {
			background-image: url("https://drive.google.com/uc?export=view&id=1vUXivbstGGf8-MVaTo_hdK07IreEpjWQ");
        }
        .player {
			background-image: url("https://drive.google.com/uc?export=view&id=1-6HhmroiJrkPUw2LhiDY-nb46K-kUYSA");
			animation:blink 1.9s infinite
        }
		.baseGround{
			background-color:rgb(0,139,139);
		}
		@keyframes blink {
		 0% {
		  opacity: 0;
		 }
		 50% {
		  opacity: 1;
		 }
		 100% {
		  opacity: 0;
		 }
    </style> 
</head>
<body>
    <div id="status"></div> 
	<textarea id="log" style="width: 469px; height: 67px;"></textarea>
    <table id="map" class ="baseGround"></table>
    <script>
        const status = document.querySelector('#status');
        const log = document.querySelector('#log');
        const map = document.querySelector('#map');
        const width = 20;
        const height = 40;
        const mapData = [];
        const monsters = [];
        const treasures = [];
        const touchSlideDistance = 100;

        for (let y = 0; y < height; y++) {
            mapData.push([]);
            const row = document.createElement('tr');
            for (let x = 0; x < width; x++) {
                const cell = document.createElement('td');
                if (Math.random() < 0.2) {
                    mapData[y].push('#');
                    cell.classList.add('wall'); 
                } else if (Math.random() < 0.1) {
					mapData[y].push('M');
                    cell.classList.add('monster');
                    monsters.push({
                        x,
                        y,
                        hp: Math.floor(Math.random() * 20) + 10,
                        atk: Math.floor(Math.random() * 5) + 1,
                        def: Math.floor(Math.random() * 3)
                    });
                } else if (Math.random() < 0.05) {
                    mapData[y].push('T');
                    cell.classList.add('treasure');
					var treasureType = Math.random();   
					treasures.push({
                        x,
                        y,
                        hp: treasureType >= 0.7 ?  Math.floor(Math.random() * 10) : 0 ,
                        atk: (0.3 < treasureType && treasureType < 0.7) ? Math.floor(Math.random() * 3) : 0,
                        def: treasureType <= 0.3 ? Math.floor(Math.random() * 3) : 0
                    });
                } else {
                    mapData[y].push('.');
                }
                row.appendChild(cell);
            }
            map.appendChild(row);
        }

        const player = {
            x: Math.floor(width / 2),
            y: Math.floor(height / 2),
            hp: 100,
            atk: 10,
            def: 0
        };
        updateStatus();
        mapData[player.y][player.x] = 'P';
        map.children[player.y].children[player.x].classList.add('player');

        function updateStatus() {
            status.textContent = `HP: ${player.hp} ATK: ${player.atk} DEF: ${player.def}`;
        }

        function attack(attacker, defender) { 
			const damage = Math.max(0, attacker.atk - defender.def);
            defender.hp -= damage;
            log.value += `${attacker === player ? 'Player' : 'Monster'} Attck!Dealing ${damage} damage to ${defender === player ? 'Player' : 'Monster'}\n`;
            if (defender.hp <= 0) {
                if (defender === player) {
                    alert('Game Over!');
                }else {
                    log.value += 'Monster is defeated!\n';
                    const index = monsters.findIndex(monster => monster === defender);
                    if (index !== -1) {
                        monsters.splice(index, 1);
                        mapData[defender.y][defender.x] = '.';
                        map.children[defender.y].children[defender.x].classList.remove('monster');
						
						if(monsters.length == 0){
							setTimeout(
								function(){
									alert('Dungeon Clear!');
								}
							,1000);
						}
                    }
                }
				
            }
			log.scrollTop = log.scrollHeight;
        }

        document.addEventListener('keydown', ControlEvent,false);
        document.addEventListener('touchstart', handleTouchStart,false); 
        document.addEventListener('touchmove', ControlEvent,false);

		var xDown = null;                                                        
		var yDown = null;

		function getTouches(evt) { 
		  return evt.touches ||             // browser API
				 evt.originalEvent.touches; // jQuery
		}                                                     
																				 
		function handleTouchStart(evt) {  
			const firstTouch = getTouches(evt)[0];                                      
			xDown = firstTouch.clientX;                                      
			yDown = firstTouch.clientY;                                      
		};               
		
		function ControlEvent(event){
		
            let newX = player.x;
            let newY = player.y;
            if (event.key === 'ArrowUp') {
                newY--;
            } else if (event.key === 'ArrowDown') {
                newY++;
            } else if (event.key === 'ArrowLeft') {
                newX--;
            } else if (event.key === 'ArrowRight') {
                newX++;
            } else if (event.key === 'Space') {
            }
			
			if (event.key === '2') {
                newY++;
            } else if (event.key === '8') {
                newY--;
            } else if (event.key === '4') {
                newX--;
            } else if (event.key === '6') {
                newX++;
            } else if (event.key === '9') {
				newY--;
                newX++;
            } else if (event.key === '7') {
				newY--;
                newX--;
            } else if (event.key === '3') {
				newY++;
                newX++;
            } else if (event.key === '1') {
				newY++;
                newX--;
            }  

			if ( ! xDown || ! yDown ) {
				return;
			}

			var xUp = event.touches[0].clientX;                                    
			var yUp = event.touches[0].clientY;

			var xDiff = xDown - xUp;
			var yDiff = yDown - yUp;

			if ( Math.abs( xDiff ) > Math.abs( yDiff ) ) { 
				if ( xDiff > touchSlideDistance ) {
					newX--;
				} else if( xDiff < -touchSlideDistance ){
					newX++;
				} else　{
                    return;
                }                       
                 
			} 
            else {
                  
				if ( yDiff > touchSlideDistance ) {
					newY--;
				} else if( yDiff < -touchSlideDistance ){ 
					newY++;
				} else　{
                    return;
                }                                                                   
			} 
		   
			xDown = null;										
            yDown = null;
			PlayerMove(newX,newY);
        }
		
		
		function PlayerMove(newX,newY)
		{
			if (newX >= 0 && newX < width && newY >= 0 && newY < height && mapData[newY][newX] !== '#') {
                if (mapData[newY][newX] === 'M') {
                    const monster = monsters.find(monster => monster.x === newX && monster.y === newY);
                    if (monster) {
                        attack(player, monster);
                        attack(monster, player);
                        updateStatus();
                    }
                } else if (mapData[newY][newX] === 'T') {
					
					const treasure = treasures.find(treasure => treasure.x === newX && treasure.y === newY);
                    player.hp+=treasure.hp;
                    player.atk+=treasure.atk;
                    player.def+=treasure.def; 
					log.value += `Got Treasure!hp+${treasure.hp} atk+${treasure.atk} def+${treasure.def}!\n`;
                    updateStatus();
                    mapData[newY][newX] = '.';
                    map.children[newY].children[newX].classList.remove('treasure');
                } else { 
					mapData[player.y][player.x] = '.';
                    map.children[player.y].children[player.x].classList.remove('player');
                    player.x = newX;
                    player.y = newY;
                    map.children[player.y].children[player.x].classList.add('player');  
					mapData[player.y][player.x] = 'P';
				}
            } 
			
			monsters.forEach(element => {     
						var xMove = Math.round(Math.random());
						var yMove = Math.round(Math.random()); 
						var newMx = Math.random() > 0.5 ? element.x + xMove : element.x - xMove;
						var newMy = Math.random() > 0.5 ? element.y + yMove : element.y - yMove;
		
						if(newMy === player.y && newMx === player.x)
						{
							attack(player, element);
							attack(element, player);
							updateStatus();
						}
						else if(newMx >= 0 && newMx < width && newMy >= 0 && newMy < height &&
						   mapData[newMy][newMx] !== '#' &&
						   mapData[newMy][newMx] !== 'T' &&
						   mapData[newMy][newMx] !== 'M' 
						   )
						{
							mapData[element.y][element.x] = '.';
							map.children[element.y].children[element.x].classList.remove('monster'); 
							element.x = newMx;
							element.y = newMy;
							map.children[element.y].children[element.x].classList.add('monster');  
							mapData[element.y][element.x] = 'M';
						}
						
					}); 
		}
		
    </script>
</body>
</html>